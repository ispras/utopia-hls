nodetype<latency=1> source() => (X<1.0> x, Y<1.0> y);
nodetype<latency=1> split(X<1.0> x) => (X<0.5> x1, X<0.5> x2);
nodetype<latency=3> kernel1(X<1.0> x, Y<0.5> y) => (Z<0.25> z, W<1.0> w);
nodetype<latency=5> kernel2(X<0.5> x, W<0.5> w) => (Z<0.25> z);
nodetype<latency=1> merge(Z<0.5> z1, Z<0.5> z2) => (Z<1.0> z);
nodetype<latency=1> sink(Z<1.0> z) => ();

graph G {
  chan X x1;
  chan X x2;
  chan X x;
  chan Y y;
  chan Z z1;
  chan Z z2;
  chan Z z;
  chan W w;

  node source n1() => (x, y);
  node split n2(x) => (x1, x2);
  node kernel1 n3(x1, y) => (z1, w);
  node kernel2 n4(x2, w) => (z2);
  node merge n5(z1, z2) => (z);
  node sink n6(z) => ();
}
